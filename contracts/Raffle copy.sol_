// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "@openzeppelin/contracts/utils/Counters.sol";
import "./IAdmin.sol";
import "./RaffleData.sol";


interface IERC20Contract {
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    function balanceOf(address tokenOwner) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

interface IERC1155Contract {
    function balanceOf(address tokenOwner, uint256 id) external view returns (uint256);
    function burn(address tokenOwner, uint256 id) external;
    function getType(uint256 id) external view returns (uint8);
}

interface Helper {
    function calcPrice(uint32 units, uint256 currentSupply) external view returns (uint256);
    function random(uint256 limit) external view returns (uint16);
    function getCurrentRewards(uint256 _raffle_supply) external pure returns (uint64);
    function isValidAdmin(address adminAddress) external pure returns (bool);
}

interface CapsuleInterface {
    function claim(uint256[] memory ticketIds, address raffleAddress, address receiver) external;
}

interface IRaffleData111 {

}


contract Raffle222 {

    IERC20Contract _loaContract;
    Helper _helper;
    RaffleData _raffleData;
    IAdmin _admin;
    
    event TicketMinted(
        uint256 indexed units,
        address indexed buyer,
        uint256 totalPrice
    );

    event WinnersDeclared(
        uint256[] ticketIds
    );

    constructor(address loaContract, address adminAddress, address raffleHelper , address raffleData) 
        ERC1155("https://raffle.leagueofancients.com/api/ticket/{id}.json") {
        _helper = Helper(raffleHelper);
        _loaContract = IERC20Contract(loaContract);
        _raffleData = RaffleData(raffleData);
        _admin = IAdmin(adminAddress);
    }

    modifier validAdmin() {
        require(_helper.isValidAdmin(msg.sender) , "You are not authorized.");
        _;
    }

    function burn(address owner, uint256 id) public payable {
        require(msg.sender == _admin.getCapsuleAddress(), "You are not authorized to burn");
        _burn(owner, id, 1);
        _raffleData.burn(owner, id);
    }


    // User can buy raffle ticket by providing raffileType and no of units
    function buyTicket(uint32 units) public payable {

        require(_raffleData._raffle_status == 1, "Raffle is not open." );
        require(_raffleData._raffle_start_time < block.timestamp, "Raffle is not open." );
        require(_raffleData._raffle_end_time > block.timestamp, "Raffle is closed." );
        require(units > 0, "Invalid units provided." );

        uint256 amount = _helper.calcPrice(units,_raffleData._raffle_supply);

        require( _loaContract.balanceOf(msg.sender) >= amount, "Required LOA balance is not available.");

        _loaContract.transferFrom(msg.sender, address(this), amount);

        uint256 ticketPrice = amount / units;

        uint256[] memory ids = _raffleData.buyTicket(ticketPrice, units);
        for (uint256 i = 0; i < ids.length; i++) {
            _mint(msg.sender, ids[i], 1, "");
        }
    
        emit TicketMinted(units, msg.sender, amount);
    }

    function burn(address owner, uint256 id, uint256 amount) public {
        require(msg.sender == _raffleData, "Not authorized");
        super._burn(owner, id, amount);
    }

    function pickWinner(uint256 count) public validAdmin {
        uint64 rewards = _helper.getCurrentRewards(_raffleData._raffle_supply);

        uint256[] memory winners = _raffleData.pickWinner(count, rewards);
        emit WinnersDeclared(winners);
    }

    function withdraw(address tokenAddress) public {
        if (tokenAddress == address(0)) {
            payable(_admin.getTreasury()).transfer(address(this).balance);
            return;
        }
        if(_raffleData._refund_address_to_amount[msg.sender] > 0) {
            require( _loaContract.balanceOf(address(this)) >= _raffleData._refund_address_to_amount[msg.sender], "Low tresury balance");
            _loaContract.transfer(msg.sender, _raffleData._refund_address_to_amount[msg.sender]);
        }
        if(_helper.isValidAdmin(msg.sender)) {
            IERC20Contract(tokenAddress).transfer(_admin.getTreasury(), IERC20Contract(tokenAddress).balanceOf(address(this)));
            IERC20Contract(tokenAddress).transfer(_admin.getTreasury(), IERC20Contract(tokenAddress).balanceOf(address(this)));
        }
        if(_raffleData._raffle_status == 3 && _raffleData._user_tickets[msg.sender].length > 0) {
            CapsuleInterface(_admin.getCapsuleAddress()).claim(_raffleData._user_tickets[msg.sender], address(this), msg.sender);
        }

        // for(uint256 i = 0; i < ticketIds.length; i++) {
        //         _ticket_status[ticketIds[i]] = 2;
        //         _refund_address_to_amount[_ticket_owner[ticketIds[i]]] += _ticket_price[ticketIds[i]];
        //         _raffle_tickets_count[_ticket_owner[ticketIds[i]]] = 0;

        //         IRaffle(msg.sender).burn(_ticket_owner[ticketIds[i]], ticketIds[i], 1);

        //         for(uint256 j = 0; j < _user_tickets[_ticket_owner[ticketIds[i]]].length; j++) {
        //             if(_user_tickets[_ticket_owner[ticketIds[i]]][j] == ticketIds[i]) {
        //                 _user_tickets[_ticket_owner[ticketIds[i]]][j] = _user_tickets[_ticket_owner[ticketIds[i]]][_user_tickets[_ticket_owner[ticketIds[i]]].length - 1];
        //                 _user_tickets[_ticket_owner[ticketIds[i]]].pop();
        //                 break;
        //             }
        //         }
        //     }
    }
}
